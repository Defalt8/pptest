#pragma once
#ifndef PPTEST
#define PPTEST

#include <cstddef>
#include <cstdint>
#include <cstdio>

namespace pptest {

using cstring_t = char const *;

template <class C> class Test;
template <class C> class Testcase;

enum class Status
{
	Unknown = 0,
	Pass,
	Fail
};

static constexpr cstring_t cstr_status[]
{
	"Unknown",
	"Pass",
	"Fail"
};


struct FilePosition
{
	cstring_t _file = nullptr;
	int       _line = 0;
};

struct Assertion
{
	cstring_t      _command   = nullptr;
	cstring_t      _assertion = nullptr;
	cstring_t      _file      = nullptr;
	int            _line      = 0;
	bool           _breaking  = false;
	Status         _status    = Status::Unknown;
};

struct ReporterSettings
{
	bool _report_pass = false;
	bool _report_fail = true;
	bool _report_testcase_run = true;
	bool _report_testcase_end = false;
	bool _report_test_run = true;
	bool _report_test_end = true;
	bool _report_unhandled_exception = true;
};

template <class C>
class Reporter
{
 public:
	virtual ~Reporter() = default;

	virtual void report_test_run(Test<C> & test_) noexcept
	{}

	virtual void report_test_end(Test<C> & test_, int passed_, int failed_) noexcept
	{}

	virtual void report_testcase_run(Test<C> & test_, Testcase<C> & testcase_) noexcept
	{}

	virtual void report_testcase_end(Test<C> & test_, Testcase<C> & testcase_, int passed_, int failed_) noexcept
	{}

	virtual void report_pass(Test<C> & test_, Testcase<C> & testcase_, Assertion const & assertion) noexcept
	{}

	virtual void report_fail(Test<C> & test_, Testcase<C> & testcase_, Assertion const & assertion) noexcept
	{}

	virtual void report_unhandled_exception(Test<C> & test_, Testcase<C> & testcase_) noexcept
	{}

};

template <class C>
class StdReporter : public Reporter<C>
{
	void _report_assertion(Assertion const & assertion)
	{
		printf("      | %-4s | %32s:%-5d | %s(%s)\n"
			, cstr_status[int(assertion._status)]
			, assertion._file, assertion._line
			, assertion._command, assertion._assertion);
		fflush(stdout);
	}

	ReporterSettings _settings {};

 public:
	virtual ~StdReporter() = default;

	StdReporter() = default;

	StdReporter(ReporterSettings const & settings_)
		: _settings { settings_ }
	{}

	virtual void report_test_run(Test<C> & test_) noexcept override
	{
		if(_settings._report_test_run)
		{
			printf("\n- %s: \n", test_.name());
			fflush(stdout);
		}
	}

	virtual void report_test_end(Test<C> & test_, int passed_, int failed_) noexcept override
	{
		if(_settings._report_test_end)
		{
			printf("\n--- End of %s | %d/%d passed.\n", test_.name(), passed_, (failed_+passed_));
			fflush(stdout);
		}
	}

	virtual void report_testcase_run(Test<C> & test_, Testcase<C> & testcase_) noexcept override
	{
		if(_settings._report_testcase_run)
		{
			printf("\n  - %s \n", testcase_.name());
			fflush(stdout);
		}
	}
	

	virtual void report_testcase_end(Test<C> & test_, Testcase<C> & testcase_, int passed_, int failed_) noexcept override
	{
		if(_settings._report_testcase_end)
		{
			printf("  --- end of %s  | %d/%d passed.\n", testcase_.name(), passed_, (failed_+passed_));
			fflush(stdout);
		}
	}

	virtual void report_pass(Test<C> & test_, Testcase<C> & testcase_, Assertion const & assertion) noexcept override
	{
		if(_settings._report_pass)
			_report_assertion(assertion);
	}

	virtual void report_fail(Test<C> & test_, Testcase<C> & testcase_, Assertion const & assertion) noexcept override
	{
		if(_settings._report_fail)
			_report_assertion(assertion);
	}

	virtual void report_unhandled_exception(Test<C> & test_, Testcase<C> & testcase_) noexcept override
	{
		if(_settings._report_unhandled_exception)
		{
			printf("      | Unhandled Exception | %s:%d\n", testcase_.file_position()._file, testcase_.file_position()._line);
			fflush(stdout);
		}
	}

};


template <class C>
class Test
{
	FilePosition _file_position {};
	C          * _test = nullptr;
	cstring_t    _name = nullptr;

 protected:
	Test(FilePosition const & file_position_, C & test_, cstring_t name_)
		: _file_position { file_position_ }
		, _test { &test_ }
		, _name { name_ }
	{}

 public:
	virtual ~Test() = default;
	 
	template <template <typename...> class R> 
	int run_all(R<C> && reporter_)
	{
		return this->run_all(static_cast<Reporter<C> &>(reporter_));
	}
	 
	int run_all()
	{
		Reporter<C> no_reporting;
		return this->run_all(no_reporting);
	}

	int run_all(Reporter<C> & reporter_)
	{
		auto & test_ = *_test; 
		auto & testcases_ = test_._testcase_mptrs;
		reporter_.report_test_run(test_);
		int passed_ = 0;
		int failed_ = 0;
		int last_passed_ = 0;
		int last_failed_ = 0;
		bool break_ = false;
		for(auto & testcase_ptr : testcases_)
		{
			auto & testcase = *(test_.*testcase_ptr);
			reporter_.report_testcase_run(test_, testcase);
			try 
			{
				testcase.run(reporter_, passed_, failed_);
			}
			catch(Assertion const & ex)
			{}
			catch(...)
			{
				++failed_;
				break_ = true;
				reporter_.report_unhandled_exception(test_, testcase);
			}
			reporter_.report_testcase_end(test_, testcase
				, (passed_ - last_passed_), (failed_ - last_failed_));
			last_passed_ = passed_;
			last_failed_ = failed_;
			if(break_)
				break;
		}
		reporter_.report_test_end(test_, last_passed_, last_failed_);
		return failed_;
	}
	
	void _on_pass(Reporter<C> & reporter_, Testcase<C> & testcase_, Assertion const & assertion)
	{
		reporter_.report_pass(*this, testcase_, assertion);
	}

	void _on_fail(Reporter<C> & reporter_, Testcase<C> & testcase_, Assertion const & assertion)
	{
		reporter_.report_fail(*this, testcase_, assertion);
		if(assertion._breaking)
			throw assertion;
	}

	FilePosition const & file_position() const { return _file_position; }
	C       * test() const { return _test; }
	cstring_t name() const { return _name; }

};

template <class C>
class Testcase
{
	FilePosition _file_position {};
	Test<C>    * _test = nullptr;
	cstring_t    _name = nullptr;

 protected:
	Testcase(FilePosition const & file_position_, Test<C> * test_, cstring_t name_)
		: _file_position { file_position_ }
		, _test { test_ }
		, _name { name_ }
	{}
	
	void _on_assert(bool pass_, Reporter<C> & reporter_, int & passed_, int & failed_, Assertion assertion)
	{
		if(pass_)
		{
			assertion._status = Status::Pass;
			++passed_;
			_test->_on_pass(reporter_, *this, assertion);
		}
		else
		{
			assertion._status = Status::Fail;
			++failed_;
			_test->_on_fail(reporter_, *this, assertion);
		}
	}

 public:
	virtual ~Testcase() = default;

	virtual void run(Reporter<C> & reporter_, int & _passed_, int & _failed_) = 0;
	
	FilePosition const & file_position() const { return _file_position; }
	Test<C> * test() const { return _test; }
	cstring_t name() const { return _name; }

};


// snake-case aliases
using status    = Status;
using assertion = Assertion;
using reporter_settings = ReporterSettings;
template <class C> using reporter      = Reporter<C>;
template <class C> using std_reporter  = StdReporter<C>;

} // namespace pptest


#define Assert_IMPL(P, Command, Breaking, ...) \
		this->_on_assert(P(__VA_ARGS__), _pptest_reporter_, _pptest_passed_, _pptest_failed_, pptest::Assertion { Command,#__VA_ARGS__, __FILE__, __LINE__, Breaking })

#define CHECK_THROWER(...) __VA_ARGS__
#define ASSERT_THROWER(...) throw __VA_ARGS__;

#define Check_True(...) Assert_IMPL(,"Check_True",false,__VA_ARGS__)
#define Assert_True(...) Assert_IMPL(,"Assert_True",true,__VA_ARGS__)

#define Check_False(...) Assert_IMPL(!,"Check_False",false,__VA_ARGS__)
#define Assert_False(...) Assert_IMPL(!,"Assert_False",true,__VA_ARGS__)


#define TESTCASE_ID(...) _tc_##__VA_ARGS__
#define TESTCASE_PTR_ID(...) _tcptr_##__VA_ARGS__


// Begin_Test
#define Begin_Test(TestID) \
	struct TestID : public pptest::Test<TestID> \
	{ \
		TestID() \
			: pptest::Test<TestID> { { __FILE__, __LINE__ }, *this, #TestID } \
		{}


// Begin_Testcase
#define Begin_Testcase(TestID,TestcaseID) \
		struct TestcaseID : public pptest::Testcase<TestID> \
		{ \
			TestcaseID(TestID & test_) \
				: Testcase<TestID> { { __FILE__, __LINE__ }, &test_, #TestcaseID } \
			{} \
			void run(pptest::Reporter<TestID> & _pptest_reporter_, int & _pptest_passed_, int & _pptest_failed_) override 


// End_Testcase
#define End_Testcase(TestID,TestcaseID) \
		} TESTCASE_ID(TestcaseID) { *this }; \
		pptest::Testcase<TestID> * const TESTCASE_PTR_ID(TestcaseID) = &TESTCASE_ID(TestcaseID);


// Begin_Testcase_Registration
#define Begin_Testcase_Registration(TestID) \
		static constexpr thread_local pptest::Testcase<TestID> * const TestID::* \
		_testcase_mptrs[] \
		{ 


// Register_Testcase
#define Register_Testcase(TestID, TestcaseID) \
			&TestID::TESTCASE_PTR_ID(TestcaseID),


// End_Testcase_Registration
#define End_Testcase_Registration(TestID) \
		}; \
		static constexpr thread_local size_t _testcase_size \
			= sizeof(_testcase_mptrs) / sizeof(_testcase_mptrs[0]);


// End_Test
#define End_Test(TestID) \
	};


#endif // PPTEST